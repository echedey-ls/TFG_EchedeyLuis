\chapter{Desarrollo} \label{chp:desarrollo}

La primera parte de este capítulo describe el \textit{modus operandi} del autor de este Trabajo Fin de Grado para contribuir a la librería de modelado fotovoltaico \textit{pvlib-python}, en el que se detallan las herramientas y el entorno de desarrollo empleados.

En el resto de secciones se tratarán las contribuciones de todo índole realizadas, abiertas o planificadas, agrupadas por la temática y la importancia. En aquellas más complejas, se describirán las bases teóricas y se contará el resultado de la propuesta, si es aceptado o no.

\section{Entorno de desarrollo y herramientas utilizadas} \label{sct:desarrollo:entorno}

En el caso del autor de este Trabajo Fin de Grado, se emplea el siguiente software para el desarrollo del proyecto consistentemente:

\begin{itemize}
    \item \textit{Visual Studio Code}: es el editor de código que se emplea para escribir y editar el código fuente del proyecto. Es un editor de código semi-abierto, ligero y rápido que cuenta con una amplia gama de extensiones para facilitar el desarrollo de software. Es una alternativa multipropósito a otros editores de código como \textit{PyCharm} o \textit{Spyder} en el caso de Python. Es importante denotar que la gran inmensa utilidad que proporciona \textit{VSCode} es gracias a las extensiones creadas por la comunidad de desarrolladores, que permiten desde la edición de archivos de texto plano hasta la depuración de código, pasando por la integración con servicios de control de versiones y la ejecución de tests de forma visual. He aquí extensiones que se emplean en el desarrollo del proyecto:
          \begin{itemize}
              \item \textit{Python}: es la extensión que se emplea para el desarrollo de código en Python. Proporciona funcionalidades como el autocompletado de código, la visualización de la documentación de las funciones, la ejecución de scripts y la depuración de código.
              \item \textit{Ruff}: permite formatear el código según las directrices de estilo de \textit{flake8}.
              \item \textit{GitHub Copilot}: un asistente de generación de código en línea integrado en el editor, que se emplea para sugerir fragmentos de código y documentación en función del contexto. Agiliza el desarrollo.
              \item \textit{Code Spell Checker}: es un corrector ortográfico que se emplea para detectar errores de ortografía en el código y en la documentación.
              \item \textit{Jupyter Notebooks}: es la extensión que se emplea para editar y ejecutar \textit{notebooks} de Jupyter en el editor, un formato que permite visualizar las variables del contexto y facilita el debugging interactivo. Los ejemplos de \textit{pvlib-python} se realizan con un formato similar a las celdas de texto o código de una \textit{notebook}.
              \item Resaltado de sintaxis de varios formatos de archivos, como \textit{reStructuredText}, \textit{Markdown}, \textit{YAML} y \textit{TOML}: para facilitar la edición de la documentación y los archivos de configuración.

          \end{itemize}

    \item \textit{GitHub Desktop}: es la interfaz gráfica que se emplea para colaborar en el desarrollo del proyecto. Permite visualizar los cambios, crear \textit{ramas}, hacer \textit{commits}, \textit{pull requests} y \textit{merges}, entre otros. En resumen, administra nuestra copia del repositorio para que los desarrolladores del proyecto puedan revisar y aceptar las propuestas.
    \item \textit{pip} y \textit{venv}: como gestor de paquetes y entornos aislados de desarrollo de Python nativos. Se emplean para instalar las dependencias del proyecto y usar entornos con las versiones específicas requeridas aislado del resto del sistema.


\end{itemize}

De forma discreta, se ha hecho uso de otras herramientas como:

\begin{itemize}
    \item \textit{Git}: para clonar las ramas del autor de este TFG y correr partes de la integración continua, normalmente la documentación, en las máquinas virtuales de linux provistas por la UPM\footnote{Accesible a través de \url{https://escritorio.upm.es/}.}.
    \item \textit{Miniconda}: una distribución de Python que se emplea para instalar y gestionar las dependencias del proyecto. Facilita la creación de entornos virtuales y la instalación de paquetes de Python. Se utilizó para diagnosticar un error de precisión por la compilación de algunas librerías y que hacía fallar un test.
    \item \textit{LibreOffice Calc}: para generar datos de prueba y comprobar las implementaciones de las ecuaciones de los modelos.
\end{itemize}

El desarrollo de la librería se ha hecho habitualmente en Windows 10, en un portátil HP \textit{15-dw2003ns} así que se ha aprovechado a usar el subsistema de Windows para Linux (\textit{WSL}) para ejecutar tests y construir la documentación en un entorno similar al de integración continua. No obstante, por los recursos limitados del portátil, y por poder cambiar de ramas mientras se construye la documentación, se ha hecho uso de las máquinas virtuales de la UPM para ejecutar los tests y construir la documentación.

\subsection{La documentación}

En esta sección pondremos en valor lo que realmente es lo más importante de un proyecto de programación, en especial de código abierto: la documentación. Es más, se puede argumentar el valor de todas las aportaciones es documentar lo más rigurosamente posible los modelos y métodos que se implementan, tanto para dar a conocerlos como para que el uso sea correcto.

Como se comentaba anteriormente, la documentación de la librería \textit{pvlib-python} se encuentra alojada en la plataforma \textit{ReadTheDocs}, que expone los archivos HTML para que los usuarios puedan consultarla en línea. La documentación se genera automáticamente a partir de los comentarios en el código fuente, que se escriben en formato \textit{reStructuredText} y se construye con el framework \textit{sphinx}.

Existen archivos específicos para indicar qué funciones o métodos son públicos, hacer páginas de inicio, de referencia, de ejemplos, de instalación, de contribución, etc. Además, se pueden incluir imágenes, tablas, gráficos, enlaces, referencias, entre otros elementos que facilitan la comprensión de los conceptos.

\textit{sphinx} emplea el estilo de documentación de \textit{pydata-sphinx-theme}, que organiza las secciones de la documentación y da un estilo homogéneo a la web. Además, para la creación de los ejemplos se emplea la extensión \textit{sphinx-gallery}, que ejecuta unos scripts de Python por secciones similares a una \textit{notebook} de Jupyter y captura la salida de texto estándar y los gráficos para mostrarlos en la documentación.

La \textit{docstring} de cada función, que es el comentario que se escribe en la primera línea de la definición de la función y se emplea para autogenerar la documentación, utiliza el estilo de \textit{numpydoc}. Este estilo permite incluir información sobre los parámetros de entrada, los valores de retorno, las excepciones que se pueden lanzar, entre otros. Además, se pueden incluir ejemplos de uso de la función e informar avisos de precaución sobre aspectos más específicos.

A continuación, una plantilla de ejemplo de documentación y de código de una función cualquiera:

\begin{lstlisting}[language=Python, caption={Ejemplo de documentación de una función en \textit{pvlib-python}.}, label={lst:doc_function_example}]
def example_model(param1, param2):
    """
    Brief model description.

    Long model description, also found at [1]_.

    .. versionadded:: 0.1.0

    .. warning::
       This docstring is an example.

    Parameters
    ----------
    param1 : numeric
      Description of the parameter.
    param2 : numeric
      Description of the parameter.

    Returns
    -------
    float
        Return type of the function.

    Notes
    -----
    Additional notes about the function, detailed explanations if needed. Even an equation:

    .. math::

       f(x, y) = x + y

    Examples
    --------
    >>> example_model(1, 5)
    6.0

    References
    ----------
    .. [1] Author, A. (2024). Title of the paper. Journal, 1(1), 1-10. :doi:`10.0001/populate`
    """
    return float(param1 + param2)
\end{lstlisting}

Esta función, una vez listada en el archivo correspondiente del índice que nos interese -aquí usamos el submódulo \lstinline{pvlib.solarposition} como ejemplo-, creará una página como la que se muestra en la figura \ref{fig:doc_function_example}:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{./images/doc_example/function_stretch.png}
    \caption{Un ejemplo de renderizado de la documentación de una función en \textit{pvlib-python}.}
    \label{fig:doc_function_example}
\end{figure}

Por otro lado, un ejemplo cuenta con la siguiente estructura:

\begin{lstlisting}[language=Python, caption={Plantilla para elaborar un ejemplo en \textit{pvlib-python}.}, label={lst:doc_example_example}]
"""
Example title
=============

Brief model description (shown in preview card).
"""

# %%
# Text paragraph, in reStructuredText format. Can use sections, subsections, etc., and math as in LaTeX.
# More text.

# This is a comment (there is a newline above)
import matplotlib.pyplot as plt
from pvlib import example_model
print("Hello, world!")
plt.plot([1, 2, 3, 4], [1, 4, 9, 16])
plt.show()

# %%
# Return to paragraph text.

sum_val = example_model(1, 5)
print(f"Sum of 1 and 5 is {sum_val}.")
\end{lstlisting}

Este archivo, ubicado en la carpeta correcta (aquí el archivo es \lstinline{docs\examples\solar-position\example_example.py}), hará que se cree automáticamente una página como la que se muestra en la figura \ref{fig:doc_use_example}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{./images/doc_example/example_stretch.png}
    \caption{Un ejemplo de página de ejemplo en la documentación de \textit{pvlib-python}.}
    \label{fig:doc_use_example}
\end{figure}

A continuación se muestran los comandos que deben ejecutarse para construir la documentación:

\begin{itemize}
    \item En un sistema basado en \textit{Linux} o \textit{WSL}.
    \item Clonando el repositorio original de la librería con \textit{Git}.
    \item Empleando las mismas versiones que a día de la redacción de este documento se emplea en la integración continua (\textit{pvlib-python=0.11.0}) - en especial hay que hacer la instalación de Python3.8.
    \item Con el entorno aislado de desarrollo (\textit{venv}) activado.
    \item Y realizando una instalación local mediante \textit{pip}.
\end{itemize}

\begin{lstlisting}[language=bash, caption={Comandos para construir la documentación de \textit{pvlib-python}.}, label={lst:doc_build}]
# instalar Python 3.8 desde el repositorio de deadsnakes,
# en las librerias por defecto de Ubuntu no se encuentra disponible por antiguedad
sudo add-apt-repository ppa:deadsnakes/ppa -y
sudo apt-get update
sudo apt-get install python3.8 python3.8-venv -y

# clonar el repositorio de pvlib-python
git clone https://github.com/pvlib/pvlib-python
cd pvlib-python

# crear el entorno virtual, instalar pvlib y las dependencias de la documentacion
python3.8 -m venv .venv
source .venv/bin/activate
python3.8 -m pip install .[doc]

# construir la documentacion
cd docs/sphinx
make html

# abrir la documentacion en el navegador
xdg-open build/html/index.html
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Contribuciones científicas} \label{sct:desarrollo:contribuciones_cientificas}

\subsection{Modelado de ajuste espectral}

\begin{itemize}
    \item \pr{1658}
\end{itemize}

El desarrollo inició en Septiembre de 2022, en Febrero de 2023 se planteó la \textit{pull request}, que finalmente se cerró en Mayo de 2023 sin incluirse los cambios en la librería.

\subsubsection{Fundamento teórico}

El modelo \cite{Martín_Ruiz_1999} plantea una relación entre la efectividad bajo un espectro estándar y la efectividad bajo un espectro arbitrario caracterizado por la masa de aire y el índice de claridad. Al principio de la implementación, tanto el autor de este TFG como el mentor del proyecto, César Domínguez, pensaron que se trataba de un modelo de ajuste similar a otros en la literatura que corrigen la irradiancia incidente, para dar lugar a la efectiva. Ejemplos de estos modelos ya se encontraban en la librería, como el modelo desarrollado por la empresa \textit{First Solar} descrito en \cite{Lee_Panchula_2016} o el de Caballero et al. en \cite{Caballero_Fernández_Theristis_Almonacid_Nofuentes_2018}. Además, para la versión 0.11.0 de la librería un compañero del programa \textit{Google Summer of Code} implementó un par de modelos más que funcionan de la misma forma. Los modelos en cuestión crean un factor de ajuste $M$ que se define, según el estándar IEC 60904-7 \cite[Eq. (2)]{Caballero_Fernández_Theristis_Almonacid_Nofuentes_2018}:

\begin{equation}
    M = \frac
    {\int_{\lambda_1}^{\lambda_2} E(\lambda) SR(\lambda) d\lambda \int_{\lambda_3}^{\lambda_4} E^*(\lambda) d\lambda}
    {\int_{\lambda_1}^{\lambda_2} E^*(\lambda) SR(\lambda) d\lambda \int_{\lambda_3}^{\lambda_4} E(\lambda) d\lambda}
\end{equation}

Resultó que, tras un elevado esfuerzo que llevó meses, el modelo en \cite{Martín_Ruiz_1999} no se ajustaba a esta descripción, sino que planteaba la siguiente ecuación:

\begin{equation} \label{eq:ajuste_articulo_Nuria}
    M = \frac{S_{efE(\lambda)}}{S_{ef\bar{G}(\lambda)}}
\end{equation}

Sin embargo, era la fracción de las tres relaciones que se planteaban en la tesis doctoral de Nuria Martín Chivelet \cite{Martín_Chivelet_1999}, que es:

\begin{equation}
    PS = 1 - \frac{S_{efE(\lambda)}}{S_{ef\bar{G}(\lambda)}}\frac{E_{\lambda<\lambda_0}}{\bar{G}_{\lambda<\lambda_0}}\frac{\bar{G}}{E}
\end{equation}

Se puede observar que la ecuación \ref{eq:ajuste_articulo_Nuria} solo contempla una parte de la definición que aplica del ajuste espectral, por ende, invalida la aplicación que se esperaba del modelo de dicho artículo.

Es gracias a los tutores que se identifica este error tras su solicitud de compararlo con modelos ya existentes.

\subsubsection{Resultado}

Se descarta aplicar los procedimientos descritos en su tesis \cite{Martín_Chivelet_1999} por:

\begin{itemize}
    \item La ausencia de acceder al documento de forma online.
    \item La ausencia de una versión en inglés, que pueda servir como referencia.
    \item La particularidad de los datos sobre los que se hace el modelo.
\end{itemize}

Lamentablemente, incluso tras contactar presencialmente con la autora y habiendo disfrutado tanto de una explicación detallada de su modelo científico como de la posibilidad de continuar en esa misma línea de trabajo, y contando con una copia física de su tesis, se desestima continuar en esa línea de trabajo debido a las razones anteriores.

Se cierra la propuesta tres meses después de plantearla.

\subsection{Proyección del cenit solar sobre las coordenadas de un colector} \label{sct:desarrollo:contribuciones_cientificas:proyeccion_cenit}

\begin{itemize}
    \item \issue{1734}
    \item \pr{1904}
\end{itemize}

Esta es la primera de una trilogía de contribuciones que se plantean para aplicar un modelo de pérdidas por sombreado en módulos con diodos bypass, cuyo autores pertenecen a la Escuela Técnica Superior de Ingeniería y Diseño Industrial, \textit{ETSIDI}. El objetivo de esta primera contribución es calcular la proyección del cenit solar sobre las coordenadas de un colector, que se emplea para calcular la fracción de sombra unidimensional en geometrías de paneles que comparten eje de rotación en común.

Las otras dos contribuciones se detallan en \ref{sct:desarrollo:contribuciones_cientificas:fraccion_sombra} y en \ref{sct:desarrollo:contribuciones_cientificas:perdidas_sombreado}.

Esta funcionalidad ya existía como parte de alguna función de la librería, así que el aporte consistió en rehacerla de nuevo empleando una referencia bibliográfica y contrastando las implementaciones. Por supuesto, la documentación se cobró la parte más importante del tiempo de desarrollo.

\subsubsection{Fundamento teórico}

Dos cálculos de bastante interés en geometría solar es obtener los ángulos óptimos de seguimiento  para un colector y calcular la fracción de sombra unidimensional incidente. Ambos cálculos tienen en común un paso muy importante, que es saber con qué ángulo inciden los rayos directos del Sol sobre la superficie del colector, pero referenciado al plano de rotación del mismo. Para facilitar el entendimiento de este concepto, es preferible imaginar un sistema de rotación de un solo eje y considerar que un colector fijo es un caso particular de un seguidor uniaxial.

Nos encontramos estos dos casos de uso:

\begin{itemize}
    \item Para el cálculo de los ángulos óptimos de seguimiento en seguidores de un solo eje, asumiendo que interesa seguir al Sol en su trayectoria diaria, se debe conocer el ángulo de incidencia de los rayos solares sobre la superficie del colector en el plano de rotación del mismo. Es decir, proyectar el cenit solar en el plano perpendicular al eje de rotación del colector, que es aquel que contiene todos los vectores normales al plano del colector.
    \item En el caso de la fracción unidimensional de sombra, interesa saber en donde impactan los límites del colector frontal sobre el trasero. Para ello, se proyecta el cenit solar en el plano perpendicular al eje de rotación del colector, que es aquel que contiene los dos vectores normales a los planos de los colectores.
\end{itemize}

Se puede encontrar en más detalle en el artículo de Lorenzo, Narvarte y Muñoz en \cite{Lorenzo_Narvarte_Muñoz_2011}, personal de la \textit{ETSIDI}, a partir del cual continúa el trabajo de \cite{Anderson_Mikofski_2020}, sección sobre \textit{True-Tracking Angle}. Esta última referencia es ampliamente utilizada a lo largo del repositorio.

\subsubsection{Resultado}

Después de cincuenta y tres comentarios en la propuesta, finalmente se incluyen los cambios como parte de la librería en la versión \texttt{0.10.4}.

Accesible en \linkDocsFunction{pvlib.shading.projected\_solar\_zenith\_angle}.

\subsection{Cálculo de fracción de sombra unidimensional} \label{sct:desarrollo:contribuciones_cientificas:fraccion_sombra}

\begin{itemize}
    \item \issue{1689}
    \item \pr{1962}
\end{itemize}

Esta propuesta es la segunda de la trilogía de propuestas para poder aplicar un modelo de pérdidas por sombreado. Continúa con la propuesta anterior, \ref{sct:desarrollo:contribuciones_cientificas:proyeccion_cenit}, y se encarga de calcular la fracción de sombra unidimensional en paneles con determinadas geometrías. La última propuesta de la trilogía es \ref{sct:desarrollo:contribuciones_cientificas:perdidas_sombreado}.

Aquí se plantea la aplicación de un modelo para conocer la fracción de sombra unidimensional en paneles que comparten eje de rotación en común. La implementación se basa en \cite{Anderson_Jensen_2024}. No obstante, la implementación inició con un póster de una conferencia anterior, a partir de una propuesta de cambios de un trabajador de \textit{First Solar} en la librería \textit{pvlib-python}, que se puede consultar en \url{https://github.com/pvlib/pvlib-python/pull/1725}.

\subsubsection{Fundamento teórico}

El modelo propuesto en \cite{Anderson_Jensen_2024} parte de un diseño de dos colectores que comparten la misma dirección del eje, y uno se encuentra más cercano al Sol que el otro. Lo interesante de este diseño es que tiene en cuenta múltiples variables de diseño, como la pendiente, la separación entre el eje y el plano colector, e inclinaciones distintas del colector sombreado y el que sombrea.

Se requiere conocer el ángulo proyectado del cenit. A partir de este ángulo, mediante intersección de rectas, se puede conocer la fracción de sombra unidimensional. Realmente se trata de una función muy compleja por el número de entradas que tiene, pues adicionalmente el cálculo de esta proyección se hace internamente en la función para simplificar la API - es decir, la interfaz programática que usarán los usuarios puede resultar densa.

Se llama fracción de sombra \textbf{unidimensional} porque se mide la fracción de sombra a lo largo de la línea del avance para una misma azimuth pero distinta elevación solar. Normalmente este valor es el que dota de mayor información, pues los cambios de la sombra debido a la azimuth no cobran tanta importancia en la mayoría de ubicaciones terrestres. Son aquellas más cercanas a los polos los que más se ven afectados por la cambiante azimuth. A continuación, la imagen \ref{fig:fraccion_sombra} muestra un esquema del sistema y su parte sombreada:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{./images/shading_1d/Anderson_Jensen_Fig3.png}
    \caption{Esquema dos colectores parametrizados, donde uno sombrea al otro. La nomenclatura corresponde la ecuación \ref{eq:sombra_t}.\\Fuente: Figura 3 en \cite{Anderson_Jensen_2024}.}
    \label{fig:fraccion_sombra}
\end{figure}

Las ecuaciones relevantes implementadas son (12) y (13) de \cite{Anderson_Jensen_2024}, \ref{eq:sombra_t} y \ref{eq:sombra_clip} respectivamente en este documento:

\begin{equation} \label{eq:sombra_t}
    \begin{aligned}
        t^* = & \ \frac{1}{2} \left( 1 + \left|\frac{\cos(\theta_1 - \theta_s)}{\cos(\theta_2 - \theta_s)}\right| \right)                                            \\
              & + sgn(\theta_s) \frac{z_0}{\ell} \left( \frac{\sin(\theta_2 - \theta_s) - \sin(\theta_1 - \theta_s)}{\left|\cos(\theta_2 - \theta_s)\right|} \right) \\
              & - \frac{p}{\ell} \left( \frac{\cos(\theta_s - \beta_c)}{\left|\cos(\theta_2 - \theta_s)\right| \cos(\beta_c)} \right)
    \end{aligned}
\end{equation}

\begin{equation} \label{eq:sombra_clip}
    f_s =
    \begin{cases}
        0   & \quad \text{si } t^* < 0 \\
        t^* & \quad 0 \leq t^* \leq 1  \\
        1   & \quad \text{si } t^* > 1 \\
    \end{cases}
\end{equation}

\subsubsection{Resultado}

Después de 102 comentarios en la propuesta, finalmente se incluyen los cambios como parte de la librería en la versión \texttt{0.11.0}, junto con un ejemplo ilustrativo que tiene en cuenta posibles dificultades que pueda encontrar un usuario\footnote{Véase en \url{https://pvlib-python.readthedocs.io/en/latest/gallery/shading/plot_shaded_fraction1d_ns_hsat_example.html}.}.

Accesible en \linkDocsFunction{pvlib.shading.shaded\_fraction1d}.

Además, como anécdota se ha de mencionar que durante el desarrollo de esta propuesta se identifica la ausencia de ejemplos que planteasen módulos orientados al Norte (propio de las instalaciones en el hemisferio Sur) en todo el repositorio, por lo que se incluye un ejemplo de este tipo en la documentación. Se puede atribuir el mérito a Rubén Nuñez por hablar al estudiante del sesgo a favor del hemisferio norte en el mundo de la fotovoltaica.

\subsection{Pérdidas por sombreado en módulos con diodos de bypass} \label{sct:desarrollo:contribuciones_cientificas:perdidas_sombreado}

\begin{itemize}
    \item \issue{2063}
    \item \pr{2070}
\end{itemize}

Con esta propuesta finaliza la trilogía de contribuciones del modelo de pérdidas por sombreado en módulos con diodos de bypass. Las dos propuestas anteriores son descritas en \ref{sct:desarrollo:contribuciones_cientificas:proyeccion_cenit} y en \ref{sct:desarrollo:contribuciones_cientificas:fraccion_sombra}.

La propuesta es de un modelo realizado por personal de la \textit{ETSIDI} y se encarga de calcular las pérdidas por sombreado en módulos con diodos de bypass. La implementación se basa en el trabajo de Martínez-Moreno, F., Muñoz, J. y Lorenzo, E., en \cite{Martínez-Moreno_Muñoz_Lorenzo_2010}.

\subsubsection{Fundamento teórico}

Los módulos de paneles solares de silicio se conforman de múltiples células fotovoltaicas. Una célula, cuando es irradiada por la luz solar, genera una corriente eléctrica. Si conectamos todas las células en serie, la corriente generada por todas las células es la misma, pero la tensión generada por cada célula se suma. Si una célula se sombrea, la corriente generada por ella disminuye, y por tanto la corriente generada por el conjunto disminuye. Esta célula sombreada se comporta como una carga para el resto, pues deben forzar la corriente que pasa por este elemento (que se suele modelar como un diodo). Supone un riesgo de seguridad y de degradación, pues una célula sombreada puede calentarse excesivamente y dañar las capas materiales de su módulo.

La solución que se emplea industrialmente consiste en añadir \textit{diodos de bypass}. Estos permiten que, cuando una serie de células tiene sombra, la corriente mayoritaria generada por el resto de células bien iluminadas fluya a través de este diodo, y no de la célula sombreada. De esta forma, se protege frente al sobrecalentamiento y la degradación temprana.

Ha de hacerse énfasis en que un diodo protege varias células, ya que no es rentable económicamente poner un diodo por cada célula. El planteamiento que nos encontramos en \cite{Martínez-Moreno_Muñoz_Lorenzo_2010} consiste en, a partir del número de grupos de células protegidos por un diodo que se encuentran sombreados, asumir que la tensión de este grupo es nula por tener un diodo en conducción y cancelar la potencia que generaría.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{./images/bypass_diodes/bypass_diodes.png}
    \caption{Esquema de un módulo con 3 diodos de bypass.}
    \label{fig:diodos_bypass}
\end{figure}

En la imagen \ref{fig:diodos_bypass}, si suponemos que la célula número 1 está sombreada, la corriente mayoritaria generada por los grupos 17 a 32 y 33 a 48 fluye a través del diodo que está en paralelo con las células 1 a 16. No importa en este caso la corriente del grupo 1 a 16, pues la tensión de este grupo es nula por tener un diodo en conducción.

Nótese que estos grupos se definen en \cite{Martínez-Moreno_Muñoz_Lorenzo_2010} como \textit{bloques}, y un bloque está sombreado en cuanto una de sus células recibe una fracción infinitesimal de sombra.

Lo más complicado de esta contribución es explicar en detalle cómo identificar el número de bloques y su disposición en el módulo, pues existen varias posibilidades. Hay módulos lo suficientemente pequeños para que solo tengan un diodo, los hay con dos y con tres diodos, y los hay \textit{half-cut} que también tienen 3 diodos, pero con una disposición que crea 6 bloques en vez de 3. Además, la progresión de los bloques que se va sombreando depende del sistema y la geometría de las sombras.

El resultado de este modelo establece la cantidad de potencia que se perdería respecto de las mismas condiciones sin sombra, $SL = 1 - \frac{P_\text{sombreado}}{P_{no\,sombreado}}$. Además, anular la potencia de un bloque sombreado se hace sobre la componente directa de la irradiancia, que es la que normalmente genera las sombras, pues la componente difusa sigue impactando en las células sombreadas y creando un mínima parte de aporte energético.

La expresión de pérdidas de potencia es la ecuación \ref{eq:perdidas_sombreado}, Eqs. [6] y [8] en \cite{Martínez-Moreno_Muñoz_Lorenzo_2010}.

\begin{equation} \label{eq:perdidas_sombreado}
    \begin{alignedat}{3}
        (1 - F_{ES}) &= (1 - F_{GS}) \left(1 - \frac{N_{SB}}{N_{TB} + 1}\right) \qquad &\text{(6)}\\
        \left(1 - \frac{P_{S}}{P_{NS}}\right) &= \left(1 - \frac{\left[(B + D^{CIR})(1 - F_{ES}) + D^{ISO} + R\right]}{G}\right) \qquad &\text{(8)}
    \end{alignedat}
\end{equation}

\subsubsection{Resultado}

Tras unos 85 comentarios, finalmente se incluyen los cambios como parte de la librería en la versión \texttt{0.11.0}, junto con un ejemplo de caso de uso\footnote{Véase en \url{https://pvlib-python.readthedocs.io/en/latest/gallery/shading/plot_martinez_shade_loss.html}.}.

Accesible en \linkDocsFunction{pvlib.shading.direct\_martinez}.

\subsection{Fracción diaria de radiación difusa fotosintetizable en función de la fracción difusa global}

\begin{itemize}
    \item \issue{2047}
    \item \pr{2048}
\end{itemize}

Esta contribución se trata de un pequeño modelo que abre un nuevo tema en la librería: la agrivoltaica. La agrivoltaica es una técnica en la que coexisten la producción de energía solar y la producción agrícola en un mismo terreno. La ventaja es que un exceso de irradiancia puede ser perjudicial para la plantación, y el retorno económico del terreno puede ser mayor que si solo se dedicase a la producción de energía solar. Además, contribuye positivamente en la polémica de utilizar suelo exclusivamente para la producción de energía.

El modelo en cuestión es la continuación de un trabajo realizado por Spitters C. J. T. et al. que cubre la separación de irradiación en directa y difusa en general \cite{Spitters_Toussaint_Goudriaan_1986}, y que posteriormente él desglosa en dos expresiones en \cite{Spitters_1986}, que se puede sustituir una en la otra. El objetivo de este modelado que hace es calcular la fracción de irradiación difusa que es útil para las plantas -es decir, fotosintetizable- a partir de la fracción de irradiación difusa global.

\subsubsection{Fundamento teórico}

La irradiación difusa fotosintetizable (\textit{PAR}, por sus siglas en inglés), es la radiación difusa que se encuentra en el rango de longitudes de onda que las plantas pueden absorber y utilizar para la fotosíntesis. Es interesante de cara a simular el crecimiento y producción de las plantas, y se emplea en modelos de cultivo. Esto último queda fuera del alcance de la librería, pero se plantea como un paso en motivar y facilitar el diseño de sistemas agrivoltaicos.

Se utiliza irradiación diaria $[J/m^2/dia]$, en vez del valor instantáneo irradiancia propio de la simulación de sistemas fotovoltaicos $[W/m^2]$.

Un análisis de distintos modelos y la validación de los mismos que contiene la expresión única se puede encontrar en \cite{Ma_Lu_Zainali_Stridh_Avelin_Amaducci_Colauzzi_Campana_2022}. Este artículo es del cual origina la propuesta de contribución.

\subsubsection{Resultado}

Con la mayor complicación de discernir las unidades de entrada, finalmente se incluyen los cambios como parte de la librería en la versión \texttt{0.11.0}, junto con un ejemplo de uso\footnote{Véase en \url{https://pvlib-python.readthedocs.io/en/latest/gallery/agrivoltaics/plot_diffuse_PAR_Spitters_relationship.html}.}.

Accesible en \linkDocsFunction{pvlib.irradiance.diffuse\_par\_spitters}.

\subsection{Modelo de pérdidas por heterogeneidad de irradiancia por célula} \label{sct:desarrollo:contribuciones_cientificas:heterogeneidad_irradiancia}

\begin{itemize}
    \item \issue{1541}
    \item \pr{2046}
\end{itemize}

Esta contribución implementa un modelo de pérdidas sobre la potencia de salida para módulos bifaciales, es decir, aquellos que pueden recibir irradiación solar tanto por una cara delantera como por la trasera. El modelo se aplica para tener en cuenta irradiancia que no es homogénea en la superficie del módulo. Se trata del trabajo descrito en \cite{Deline_Ayala_Pelaez_MacAlpine_Olalla_2020}.
Presenta interés en sistemas bifaciales, donde la cara trasera normalmente se expone a la luz reflejada por el suelo y otras obstrucciones, y por tanto la irradiancia de esa cara no es homogénea.

\subsubsection{Fundamento teórico}

Anteriormente se explicaba el mecanismo de interconexión de células solares fotovoltaicas, y cómo una célula sombreada puede actuar como una carga para el resto de células. De forma similar ocurre a pequeña escala, cuando una o varias células reciben valores de irradiancia ligeramente distintos al resto. La célula que recibe menos irradiancia limita la corriente, y la potencia de salida del módulo se ve reducida.

Desde un punto de vista computacional, resolver un sistema de múltiples células, cada una con su propia irradiancia, es realmente costoso en tiempo y en recursos. Cada célula tendría su propia curva I-V, que representa cuanta corriente y tensión genera dependiendo del punto de tensión de trabajo. El planteamiento que se hace en \cite{Deline_Ayala_Pelaez_MacAlpine_Olalla_2020} es realizar un trabajo previo de caracterización de la heterogeneidad, cuantificarla y establecer un modelo de menor orden de complejidad.

Para caracterizar distribuciones de irradiancia, en el artículo de Deline et al. \cite{Deline_Ayala_Pelaez_MacAlpine_Olalla_2020} se plantea utilizar la desviación estándar, muy común para distribuciones normales, o la \textit{Diferencia Absoluta Media Relativa} (\textit{RMAD}, por sus siglas en inglés), que es una medida de dispersión que se argumenta ser más adecuada para distribuciones no normales \cite{Ginis_mean_difference_2003}.

La pérdida de potencia de salida $M$ se calcula con un polinomio evaluado en \textit{RMAD}:

\begin{equation} \label{eq:perdidas_heterogeneidad}
    M = 1 - \frac{P_\text{array}}{\sum P_\text{cells}}
\end{equation}

donde $P_\text{array}$ es la potencia de salida del módulo, y $P_\text{cells}$ es la potencia máxima de salida de cada célula.

Se proponen dos modelos para el polinomio que define $M$, para dos perfiles de irradiancias globales distintos: uno para sistemas sujetos fijos y otro para seguidores de un eje. No obstante, solo se implementa el de sistemas fijos ya que la referencia indica que para valores anuales parece ser más preciso.

\subsubsection{Resultado}

Tras una ardua discusión de 86 comentarios en los que se plantean distintas formas de implementar el modelo, aclaraciones sobre las unidades de entrada y salida, y modificaciones al planteamiento original, finalmente se incluyen los cambios como parte de la librería en la versión \texttt{0.11.1} (sin publicar oficialmente a día de la redacción de este documento), junto con un ejemplo de uso\footnote{Véase en \url{https://pvlib-python.readthedocs.io/en/latest/gallery/bifacial/plot_irradiance_nonuniformity_loss.html}.}.

Accesible en \linkDocsFunction{pvlib.bifacial.power\_mismatch\_deline}.

Los autores originales del modelo científico piden contrastar la implementación con la suya, y se valora hacerlo en un futuro próximo antes de la siguiente versión de la librería. Se plantea como tarea futura.

\subsection{Transformación de respuesta espectral a eficiencia cuántica externa y viceversa}

\begin{itemize}
    \item \issue{2040}
    \item \pr{2041}
\end{itemize}

Esta contribución podría calificarse de menor debido a la ausencia de dificultades en su implementación. No obstante, por dotar de una nueva funcionalidad científica a la librería, se incluye en este apartado.

La propuesta consiste en dos funciones, una inversa de la otra, que convierten la respuesta espectral y la eficiencia cuántica externa.

\subsubsection{Fundamento teórico}

La eficiencia cuántica externa es una medida de la eficiencia de una célula solar, y se define como la razón de fotones incidentes que generan una corriente eléctrica para determinado color de la luz. La respuesta espectral es la corriente generada por una célula solar en función de la longitud de onda de la luz incidente.

La relación entre ambas es la siguiente \cite[pp. 15-16, Eq. \brackettext{7}]{Markvart2012-un}:

\begin{equation}
    SR(\lambda) = \frac{q \cdot \lambda}{h \cdot c} \cdot EQE(\lambda)
\end{equation}

\subsubsection{Resultado}

Además de la relación, se añade la posibilidad de normalizar los valores de salida, es decir, hacer que el máximo retornado sea 1. Se incluyen los cambios sin mayores dificultades en la versión \texttt{0.11.0} de la librería.

Accesibles en:

\begin{itemize}
    \item \linkDocsFunction{pvlib.spectrum.qe\_to\_sr}.
    \item \linkDocsFunction{pvlib.spectrum.sr\_to\_qe}.
\end{itemize}

\subsection{Adición de base de datos de respuesta espectral de algunas tecnologías}

\begin{itemize}
    \item \issue{2037}
    \item \pr{2038}
\end{itemize}

Con esta propuesta se pretendía añadir una serie de respuestas espectrales o de eficiencia cuántica externa de células solares de distintas tecnologías comunes, para facilitar la investigación.

\subsubsection{Fundamento teórico}

Una curva de respuesta espectral indica la capacidad que tiene un semiconductor fotovoltaico en convertir la luz incidente en corriente eléctrica en función de la longitud de onda. La eficiencia cuántica externa similarmente es una medida de la eficiencia de una célula solar para convertir fotones en pares electrón-hueco.

Dependiendo de la tecnología de cada material, la respuesta varía. Además, se puede argumentar que otros aspectos constructivos también afectan, como los espesores de las capas y la presencia de impurezas.

\subsubsection{Resultado}

La propuesta no se llegó a añadir a la librería, ya que los datos provistos de un repositorio público (en Duramat\footnote{Véase \url{https://www.osti.gov/biblio/2204677}.}) no estaban respaldados por un procedimiento que garantizase que los datos fueran representativos. Se cierra la propuesta.

\subsection{Adición de espectro estándar completo ASTM G173-03}

\begin{itemize}
    \item \issue{2039}
    \item \pr{1963}
\end{itemize}

Esta adición plantea añadir las componentes de irradiancia directa y extraterrestre del estándar ASTM G173-03, que es un espectro de referencia para la radiación solar en la superficie terrestre. La componente global ya se encontraba en la librería. Se aprovecha para añadir flexibilidad y prevenir la adición de nuevos estándares, como el similar ASTM G173-23 en un futuro.

\subsubsection{Fundamento teórico}

Un espectro estándar es de gran utilidad para comparar módulos y establecer métodos idénticos de tomar las medidas en la industria. En el caso del espectro estándar ASTM G173-03, se establecen una serie de puntos entre los 280 nm y los 4000 nm que simulan una distribución espectral bastante plausible.

La irradiancia extraterrestre es la irradiancia que se recibe en el espacio, y la irradiancia directa es la irradiancia que se recibe en la superficie terrestre sin ser dispersada por la atmósfera, y la global es toda la que se recibe en la superficie terrestre.

El estándar ASTM G173-03 se encuentra en \cite{astm_g173-03}, pero los valores del espectro están disponibles abiertamente en \url{https://www.nrel.gov/grid/solar-resource/spectra-am1.5.html}.
La nueva revisión ASTM G173-23 se encuentra en \cite{astm_g173-23}, pero no cuenta con datos abiertos en la red a día de la redacción de este documento.

\subsubsection{Resultado}

Se implementa esta función más genérica, y se hace obsoleta la antigua función (\linkDocsFunction{pvlib.spectrum.get\_am15g}) que solo devolvía la componente global. Se incluyen los cambios en la versión \texttt{0.11.0} de la librería, junto con un ejemplo en la documentación\footnote{Véase en \url{https://pvlib-python.readthedocs.io/en/stable/gallery/spectrum/plot_standard_ASTM_G173-03.html}.}. El ejemplo se puede encontrar en la figura \ref{fig:espectro_astm_g173-03}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{./images/spectra/astm-g173-03.png}
    \caption{Ejemplo en la documentación con el espectro estándar ASTM G173-03 completo.}
    \label{fig:espectro_astm_g173-03}
\end{figure}

Accesible en \linkDocsFunction{pvlib.spectrum.get\_reference\_spectra}.

\subsection{Cálculo geométrico de sombras en 3D}

\begin{itemize}
    \item \issue{2069}
    \item \pr{2106}
\end{itemize}

Se ha podido comprobar que el cálculo de sombras en sistemas fotovoltaicos dentro de \textit{pvlib-python} es un tema que se ha mejorado a lo largo de este TFG. Adicionalmente, se ha podido comprobar que la librería no cuenta con una función que permita calcular sombras a partir de escenas en 3D, pero realmente parece ser un tema sobre el que hay literatura. Además, \textit{PVsyst}, un software de simulación de sistemas fotovoltaicos, cuenta con esta funcionalidad.

Todo esto se puede explorar en un artículo sobre el sombreado de campos de cultivo en sistemas agrivoltaicos \cite{Zainali_Ma_Lu_Stridh_Avelin_Amaducci_Colauzzi_Campana_2023}.

La propuesta que aquí se hace realiza una generalización del cálculo de sombras a superficies limitadas y libres en el espacio 3D.

Es importante denotar que esta propuesta está pendiente de revisión y aprobación, en especial de saber si merecerá o no la pena incluirla en la librería por la complejidad que añade y algunas modificaciones al procedimiento del artículo original.

\subsubsection{Fundamento teórico}

Para esta contribución es imprescindible tratar algunos temas de geometría y cálculo vectorial:

\begin{itemize}
    \item Definición de una recta a partir de un punto y un vector.
    \item Intersección de una recta con un plano.
    \item Traslación de puntos.
    \item Rotación de puntos respecto del origen, mediante matrices de rotación o representación de ángulos de Euler.
    \item Limitar superficies a determinadas coordenadas de otro plano.
\end{itemize}

No se ahonda en estos detalles ya que para realizar una contribución de esta índole se requiere conocer otras utilidades que nos brinden las librerías de cálculo científico en Python, como \textit{NumPy}, \textit{SciPy} y \textit{Shapely}. La primera es muy conocida por permitir el cálculo con vectores, la segunda por facilitar múltiples tipos de cálculos matemáticos y la tercera por permitir cálculos geométricos y geoespaciales. No obstante, la intersección plano-recta y la traslación de puntos son operaciones que se pueden realizar muy fácilmente con los operadores de Python.

Lo primero que necesita un flujo de trabajo de este tipo es definir coordenadas para los objetos de la escena y sus límites. Para ello, habrá de establecerse un sistema de referencia. En el caso de la propuesta realizada, se opta por cambiar el sistema de coordenadas propuesto en \cite{Zainali_Ma_Lu_Stridh_Avelin_Amaducci_Colauzzi_Campana_2023} por el de \cite{Anderson_Mikofski_2020}, que es más conocido y utilizado en la librería.

Posteriormente, una vez creadas las superficies, tanto las sombreadas como las que generan sombras, se debe calcular el vector de posición solar. Este vector se calcula a partir de la posición del Sol en el cielo, que se puede obtener con la función \linkDocsFunction{pvlib.solarposition.get\_solarposition} y con relaciones trigonométricas.

A continuación, se proyectan los vértices de las superficies que sombrean sobre el plano sombreado, y estos puntos definirán una sombra en la escena 3D. Nótese por tanto que esta sombra puede y debe tener tres coordenadas.

Para obtener la sombra 3D final, debe limitarse los límites de esta a la superficie de interés. Para esto se emplea \textit{Shapely}, que permite realizar operaciones geométricas con polígonos.

Si se desease obtener la sombra en un plano 2D, para realizar otros cálculos y facilitar la visualización, se debe realizar una traslación que ubique la figura en un plano que pase por el origen y unas rotaciones contrarias a las que definen el plano sobre la que se proyectó.

\subsubsection{Resultado}

Ahondando en los detalles, el autor de este mismo TFG decide crear un paradigma orientado a objectos para facilitar el uso de esta funcionalidad. Se plantean dos objetos, uno base para cualquier superficie poligonal (\texttt{FlatSurface}) y una especialización para superficies rectangulares, que son las más comunes en sistemas fotovoltaicos (\texttt{RectangularSurface}).

El diagrama UML resultante sería:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{./images/shading_3d/shading_classes.png}
    \caption{Diagrama UML de la propuesta de cálculo de sombras en 3D.}
    \label{fig:uml_sombreado}
\end{figure}

La elección de un diagrama tan sencillo no es arbitraria: aquí prima la simplicidad y la facilidad de revisar el código para determinar si tiene valor o no dentro de la librería \textit{pvlib-python}. Y realmente se logra muy bien facilitar la API. Véase el ejemplo desarrollado a continuación:

\begin{lstlisting}[language=Python, caption={Caso de uso de ejemplo para la propuesta de cálculo de sombras en 3D.}, label={lst:sombreado_3d}]
from pvlib.spatial import RectangularSurface
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
import shapely

solar_azimuth = 165  # degrees
solar_zenith = 75  # degrees

# Define two rows of panels
row1 = RectangularSurface(  # south-most row
    center=[0, 0, 3], azimuth=165, tilt=20, axis_tilt=10, width=2, length=20
)

row2 = RectangularSurface(  # north-most row
    center=[0, 3, 3], azimuth=165, tilt=30, axis_tilt=10, width=2, length=20
)

# Calculate shadows
shades_3d = row2.get_3D_shades_from(solar_zenith, solar_azimuth, row1)
shades_2d = row2.get_2D_shades_from(
    solar_zenith, solar_azimuth, shades_3d=shades_3d
)

# Plot
row_style = {"color": "darkblue", "alpha": 0.5}
shade_style = {"color": "dimgrey", "alpha": 0.8}
row_style_2d = {**row_style, "add_points": False}
shade_style_2d = {**shade_style, "add_points": False}

fig = plt.figure(figsize=(10, 10))

# Split the figure in two axes
gs = fig.add_gridspec(10, 1)
ax1 = fig.add_subplot(gs[0:7, 0], projection="3d")
ax2 = fig.add_subplot(gs[8:, 0])

# 3D plot
ax1.view_init(
    elev=60,
    azim=-30,  # matplotlib's azimuth is right-handed to Z+, measured from X+
)
row1.plot(ax=ax1, **row_style)
row2.plot(ax=ax1, **row_style)
for shade in shades_3d.geoms:
    if shade.is_empty:
        continue  # skip empty shades; else an exception will be raised
    # use Matplotlib's Poly3DCollection natively since experimental
    # shapely.plotting.plot_polygon does not support 3D
    vertexes = shade.exterior.coords[:-1]
    ax1.add_collection3d(Poly3DCollection([vertexes], **shade_style))

ax1.axis("equal")
ax1.set_zlim(0)
ax1.set_xlabel("West(-) <X> East(+) [m]")
ax1.set_ylabel("South(-) <Y> North(+) [m]")

# 2D plot
row2_2d = row2.representation_in_2D_space()
shapely.plotting.plot_polygon(row2_2d, ax=ax2, **row_style_2d)
for shade in shades_2d.geoms:
    shapely.plotting.plot_polygon(shade, ax=ax2, **shade_style_2d)

# Calculate the shaded fraction
shaded_fraction = sum(shade.area for shade in shades_2d.geoms) / row2_2d.area
print(f"The shaded fraction is {shaded_fraction:.2f}")
\end{lstlisting}

Debe denotarse que la mayor parte del código supone imprimir la escena y las sombras por pantalla. La parte más interesante, que es el cálculo de las sombras y la fracción sombreada, se reduce a unas pocas 14 líneas de puro código, mientras que se necesitan 27 para mostrar el resultado en 3D y 2D. La escena con las sombras es la que se muestra en la figura \ref{fig:sombreado_3d}:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{./images/shading_3d/sphx_glr_plot_spatial_row_to_row_shading_001.png}
    \caption{Ejemplo de sombreado para coordenadas solares instantáneas en 3D.}
    \label{fig:sombreado_3d}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Contribuciones técnicas} \label{sct:desarrollo:contribuciones_tecnicas}

\subsection{Arreglo a los tests de integración continua en Windows con Conda}

\begin{itemize}
    \item \issue{2000}
    \item \pr{2007}
\end{itemize}

Por causas desconocidas, pero que se pueden intuir, fallaba un test que esperaba con bastante precisión que una entrada numérica a una función que resuelve la curva I-V del diodo devolviese un cero casi exacto. Se determinó que la causa era un exceso de precisión que se le pedía al test, y esto se cumplía en determinadas arquitecturas, y se modificó para que aceptase un margen de error mayor. Se puede deducir que se debe al entorno de pre-compilación de la librería.

\subsubsection{Resultado}

El cambio se incluyó con éxito.

\subsection{Arreglo a un parámetro ignorado en una función de transposición inversa}

\begin{itemize}
    \item \issue{1970}
    \item \pr{1971}
\end{itemize}

Hasta avanzadas versiones en la librería no se añadieron los procedimientos de integración continua que existen a día de hoy y permiten identificar fallos de análisis estático en el código. Estos fallos son aquellos que se pueden identificar sin necesidad de ejecutar el código, y en este caso se trataba de un parámetro que no se estaba utilizando en una función.

Este parámetro sin usarse fue encontrado por el autor de este mismo TFG gracias al resaltado de sintaxis y procedió a modificar la función para que lo utilizase. El parámetro era \texttt{xtol} de la función \linkDocsFunction{pvlib.irradiance.ghi\_from\_poa\_driesse\_2023}. Esta función hace una transposición inversa, que es deducir la irradiancia global horizontal a partir de la irradiancia en un plano inclinado, mediante un método numérico. El parámetro \texttt{xtol} es la tolerancia absoluta en la convergencia del método numérico.

\subsubsection{Resultado}

El cambio se incluyó con éxito, aportando tests de integridad para la función.

\subsection{Dar soporte a otra función para el cálculo del IAM en el flujo orientado a objetos}

\begin{itemize}
    \item \issue{1742}
    \item \pr{1832}
\end{itemize}

El modificador del ángulo de incidencia tiene en cuenta la reflexión de la luz incidente cuando impacta oblicuamente en una superficie. La librería \textit{pvlib-python} cuenta con muchos modelos que calculan este modificador, pero no todos están disponibles en la \texttt{Modelchain}, un flujo de trabajo orientado a objetos que facilita la simulación de sistemas fotovoltaicos.

El modelo que faltaba dar soporte era un interpolador de datos ángulo-modificador, \linkDocsFunction{pvlib.iam.interp}.

\subsubsection{Resultado}

El cambio se incluyó con éxito y ahora se encuentra disponible su interfaz en la \texttt{Modelchain}, en \linkDocsFunction{pvlib.modelchain.ModelChain.interp\_aoi\_loss}.

\subsection{Suprimir una advertencia al publicar la distribución en PyPI}

\begin{itemize}
    \item \pr{1778}
\end{itemize}

Es buena práctica revisar los procedimientos que se realizan automáticamente, ya que con cierta frecuencia dan lugar a advertencias que se ignoran por no ser una cuestión crítica. Dentro de la labor que decide aplicar el autor de este TFG, se revisa manualmente el proceso de tests unitarios, construcción y publicación de la librería en PyPI, y se detecta una advertencia que se puede suprimir aportando un parámetro en el fichero del proyecto.

No se trata de nada crítico: tan sólo es la plataforma PyPI que solicita explícitamente el formato del texto de la descripción del proyecto.

\subsubsection{Resultado}

El cambio se incluyó con éxito, gracias también a la profunda revisión de un mantenedor que detectó un fallo en el formato que el autor de este TFG había especificado.

\subsection{Exponer parámetros de tolerancia para resolver el modelo de un diodo}

\begin{itemize}
    \item \issue{1249}
    \item \pr{1764}
\end{itemize}

Una de las solicitudes que algún usuario había planteado como mejora era la posibilidad de modificar los parámetros de tolerancia de los métodos numéricos que se utilizan para resolver la curva I-V de un diodo. Estos métodos son iterativos y requieren de una precisión para converger.

Por defecto la tolerancia es de $10^{-6}$, lo que a este usuario le parecía excesivo. Nótese que dependen de los parámetros de la curva del diodo que haya que resolver.

\subsubsection{Resultado}

El cambio se incluyó con éxito, y se añadieron tests profundos para asegurar que los parámetros de tolerancia se recibían adecuadamente.

\subsection{Modificar tolerancias erróneas en varios tests unitarios}

\begin{itemize}
    \item \pr{2082}
\end{itemize}

Originalmente la librería empleó un framework de testing que especificaba las tolerancias como número de decimales después de la coma. Al cambiar de framework al nuevo y más moderno \textit{pytest}, no se modificaron estos números para reflejar el nuevo significado de las tolerancias, como un margen absoluto en torno al que deben estar los números.

\subsubsection{Resultado}

El cambio se incluyó con éxito, sin diagnosticar ningún fallo derivado de esta errata.

\subsection{Arreglo de un bug que ignoraba parámetros de una función de lectura de bases de datos}

\begin{itemize}
    \item \issue{2018}
    \item \pr{2020}
\end{itemize}

En \textit{pvlib-python} existe la función \linkDocsFunction{pvlib.pvsystem.retrieve\_sam} que permite leer de bases de datos ya inclusas en la librería o remotas mediante una URL, mediante dos parámetros distintos. Resulta que si se especificaban ambos, solo se leía la base de datos de la distribución, y no la remota, sin emitir ningún aviso.

\subsubsection{Resultado}

Se aplicó un patrón de diseño que excluía la posibilidad de que ambos parámetros se especificasen a la vez, y se incluyó sin dificultades.

\subsection{Actualizar versiones de las dependencias de la documentación}

\begin{itemize}
    \item \pr{2112}
\end{itemize}

Esta contribución se trata de otro de los trabajos en curso que lleva el autor de este TFG a día de redacción de este documento. Se trata de actualizar las versiones de las dependencias de la documentación, que se construye automáticamente con \textit{Sphinx} y algunas extensiones extras, para dotar de un nuevo \textit{look-and-feel} (o, estilo) a la documentación.

\subsubsection{Resultado}

Se sigue trabajando en esta contribución, procurando que pueda pasar el mayor tiempo posible sin necesidad de ser actualizada.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Contribuciones menores} \label{sct:desarrollo:contribuciones_menores}

Aquí se tratan aquellas que no suponen un desafío ni técnico ni científico, si bien suponen y parten de la interacción en el repositorio y la identificación particular de necesidades.

\subsection{Añadir una utilidad para obtener los ficheros de ejemplo internos de la librería}

\begin{itemize}
    \item \issue{924}
    \item \pr{1763}
\end{itemize}

El objetivo consistió en añadir una función que ahorrase escribir la instrospección de la ubicación de la librería para formar las rutas manualmente.

\begin{lstlisting}[language=python, caption={Fragmento de código utilizado normalmente para obtener la ruta de los ficheros de la librería}, label={lst:example_files_current}]
import os
import pvlib

PVLIB_DIR = pvlib.__path__[0]
DATA_FILE = os.path.join(PVLIB_DIR, 'data', '723170TYA.CSV')
\end{lstlisting}

Concretamente, la propuesta crea una función que se utilizaría como sigue:

\begin{lstlisting}[language=python, caption={Fragmento de código utilizando la función propuesta para obtener la ruta de los ficheros de la librería}, label={lst:example_files_proposal}]
import pvlib

DATA_FILE = pvlib.tools.get_example_dataset_path('723170TYA.CSV')
\end{lstlisting}

Se desestima la propuesta porque se considera que primero deben reorganizarse todos los ficheros de ejemplo, si bien esto último nunca se ha puesto en marcha debido a la inmensidad de la tarea.

\subsection{Corrección de erratas en la documentación}

\begin{itemize}
    \item \pr{1599}
    \item \pr{1860}
    \item \pr{1996}
\end{itemize}

Sin mayor elaboración al respecto, se han solventado erratas en la documentación.

\subsection{Corrección de erratas en ejemplos y en código}

\begin{itemize}
    \item \pr{1776}
    \item \pr{1833}
\end{itemize}

Son pequeñas modificaciones que no requieren mayor explicación: actualizar la salida de un ejemplo y comprobar que el único script de ejemplo que no se ejecuta, lo hiciera.

\subsection{Modificación de escritura de los parámetros opcionales}

\begin{itemize}
    \item \issue{1574}
    \item \pr{1828}
    \item \pr{2084}
\end{itemize}

En Python existe un patrón de diseño que es darle el valor \texttt{None} a los parámetros opcionales, y luego comprobar si son \texttt{None} para asignarles un valor por defecto o ignorarlos si fuese el caso. Normalmente, a la hora de documentarlo lo normal es indicar que el parámetro es opcional, pero en la librería se indicaba que el valor por defecto era \texttt{None}, lo cual es redundante y obfusca las intenciones del código.

Se cambiaron todas las ocurrencias de \texttt{default None} a \texttt{optional}, aunque hubo que iterar múltiples veces para dar con todos los falsos negativos y no obtener falsos positivos. Para esta tarea se empleó el buscador en archivos integrado en \textit{Visual Studio Code}, que está basado en \textit{ripgrep} y hace uso de expresiones regulares, una forma de búsqueda y sustitución muy potente. Las expresiones regulares son un lenguaje formal que permite buscar patrones en texto, por ejemplo sustituyendo un carácter por grupos de caracteres, o buscando un patrón que se repite un número determinado de veces.

Se emplearon múltiples expresiones regulares, escritas en el sabor PCRE2, que es el que soporta \textit{ripgrep}. Según la utilidad, podemos encontrar pequeñas variaciones en la forma de escribir estas expresiones. En los \textit{commits} de la propuesta se indican todas las expresiones empleadas, pero aquí se adjuntan algunas de las usadas:

\begin{table}[H]
    \centering
    \begin{adjustbox}{max width=\textwidth}
    \begin{tabular}{l|l}
        Expresión regular & Patrón de sustitución \\
        \hline
        \texttt{(? \{8\}| \{4\})(?\textbackslash{}w*) ?: (?.*), default:? None\textbackslash{}.?} & \texttt{\$1\$2 : \$3, optional} \\
        \texttt{(? \{8\}| \{4\})(?\textbackslash{}w*) ?: (?.*), default:? None\.?} & \\
        \texttt{(? \{8\}| \{4\})(?\textbackslash{}w*) ?: (?.*) or {[}nN{]}one, optional} & \\
        \hline
        \texttt{(? \{8\}| \{4\})(?\textbackslash{}w*) ?: {[}Nn{]}one, (?.*), default:? (?.*)\textbackslash{}.?} & \texttt{\$1\$2 : \$3, default \$4} \\
        \hline
        \texttt{(? \{8\}| \{4\})(?\textbackslash{}w*) ?: (?.*) or {[}Nn{]}one(?.*)} & \texttt{\$1\$2 : \$3\$4} \\
        \hline
        \texttt{If None} & \texttt{If not specified,} \\
    \end{tabular}
    \end{adjustbox}
    \caption{Algunas de las expresiones regulares empleadas para modificar la escritura de los parámetros opcionales.}
    \label{tab:expresiones_regulares_default_none}
\end{table}

Adicionalmente se arreglaron algunos links a los \textit{DOI}, que son identificadores únicos de documentos científicos, gracias también a la búsqueda y sustitución con expresiones regulares:

\begin{itemize}
    \item Expresión de búsqueda: \texttt{(?:doi|DOI):(?!\textasciigrave{})\textbackslash s?(.*?)(\textbackslash .\textbackslash n|\textbackslash n)}
\end{itemize}
\begin{itemize}
    \item Expresión de sustitución: \texttt{:doi:\textasciigrave{}\$1\textasciigrave{}\$2}
\end{itemize}

\subsection{Limpieza de advertencias al construir la documentación}

\begin{itemize}
    \item \pr{2030}
    \item \pr{2128}
\end{itemize}

De nuevo, en la línea de erradicar advertencias en los flujos de integración continua, se eliminaron advertencias que se emitían al construir la documentación. Estas advertencias no eran críticas, pero al formar parte de unos registros que se consultan con cierta periodicidad cada vez que alguien hace contribuciones, se prefiere evitar ruido visual. De esta forma, el proceso de revisión es más eficiente y no confunde ni a los revisores ni a los contribuyentes.

Además, se mejoró así el renderizado de la documentación en bastantes casos.

\subsection{Modificar documentación de parámetros para poder ejecutar procedimientos que verifican la integridad de la librería}

\begin{itemize}
    \item \pr{1790}
\end{itemize}

Desde el punto de vista personal del autor de este trabajo, se consideró buena opción introducir procedimientos para comprobar la correcta escritura de la documentación. Sin embargo, por el hecho de introducir nuevas herramientas que no eran del todo compatibles y requerir muchas modificaciones a la base de código actual, se desestimó la propuesta tempranamente.

\subsection{Portar antiguos ejemplos de Jupyter a scripts integrados en la web}

\begin{itemize}
    \item \pr{1818}
\end{itemize}

En los inicios del repositorio, los ejemplos se redactaban en \textit{Jupyter Notebooks}, que son documentos interactivos para ejecutar código. Sin embargo, no se facilitó su acceso desde la página web, y por la complejidad que suponían, no se ejecutan con cada versión que se realizaba. Por ende, quedaron obsoletos pronto.

En esta propuesta se extraían todos los comentarios de texto y los fragmentos de código y se estilizaban para que se pudieran ejecutar y ver en la página web. Se desestimó por tratarse de ejemplos obsoletos, con poco valor didáctico y de uso. A día de hoy, se pueden encontrar en la carpeta \texttt{docs/tutorials}.

\subsection{Integración continua para verificar los links externos de la documentación}

\begin{itemize}
    \item \pr{1794}
\end{itemize}

Otra de las mejoras que el estudiante identifica como necesaria es comprobar que los links externos de la documentación funcionen correctamente, periódicamente. Resulta que el entorno de desarrollo de la documentación \textit{sphinx} permite realizar esto de forma sencilla, pero debe configurarse los comandos para crear el procedimiento de integración continua.

Se mostró interés dependiendo del revisor; otros revisores preferían integrarlo en el proceso de publicación de las versiones. Es más, algún revisor contribuyó a arreglar los links que en ese momento se diagnosticaron rotos con ayuda del estudiante para poder ejecutar el procedimiento y verificar la integridad de los cambios. A día de redacción de este documento, no se ha tomado una decisión definitiva.

\subsection{Eliminar una función obsoleta y olvidada}

\begin{itemize}
    \item \pr{2131}
\end{itemize}

La ubicación de la función \linkDocsFunction{pvlib.atmosphere.first\_solar\_spectral\_correction}\footnote{Este link podría no funcionar si finalmente se elimina.} se encontraba obsoleta tras plantear una reorganización de aquellos modelos relativos a correcciones espectrales. Se hubo avisado de su obsoleta existencia en la versión \texttt{0.10.0}, pero no se eliminó en la siguiente versión menor, \texttt{0.11.0}, que son aquellas que admiten cambios que pueden romper el código de los usuarios.

Se plantea eliminar esta ocurrencia que no tiene fecha para su desaparición, pero lo más probable es que hasta una versión menor posterior no se elimine ya que supone cambios que pueden romper el código de usuarios. La siguiente es la versión menor \texttt{0.12.0}, aunque la versión de arreglos \texttt{0.11.1} se encuentra en desarrollo y se espera que se publique en Septiembre.

La propuesta se mantiene abierta a día de hoy.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Interacción con otros usuarios}

Ha sido constante la comunicación con los revisores y los contribuyentes que más activos son en la librería. Se ha procurado perseguir una comunicación clara, concisa y razonada, y se ha agradecido la colaboración y la transmisión de nuevas ideas, si bien no se han aplicado todas. Este caso es el más esperable, pues se tratan de las personas con más responsabilidad sobre la librería.

Por otro lado, se ha ayudado a guiar a los compañeros alumnos del \textit{Google Summer of Code} en sus propuestas y reuniones.

Y finalmente, con el sector de usuarios que discretamente han participado, bien por dudas o por descubrir errores, se ha transmitido y aportado con claridad y amabilidad.

A continuación se puede encontrar en más detalle estos dos últimos grupos, que son lo de mayor interés.

\subsection{Revisión de propuestas de otros usuarios}

En especial con aquellos compañeros partícipes bajo la subvención de \textit{Google Summer of Code}, pero también con otros usuarios que han planteado propuestas en la librería, se ha colaborado en la revisión de sus propuestas.

Se podrían citar muchos ejemplos, ya que esta parte es bastante abundante por requerir un esfuerzo relativamente bajo: incluso revisando un propuesta basada en algún artículo, pero no pudiendo consultar este, se puede aportar mucho. Normalmente se ha revisado el renderizado y claridad de la documentación, y la integridad de los tests. Se presta máxima atención a la parte más social, dar el crédito a todos los nuevos implicados en la librería.

En otras situaciones, se ha aportado información técnica sobre normativa, como en una propuesta de un modelo de pérdidas en transformadores. Revisores del código pidieron información sobre los tests que se realizan físicamente en transformadores de alta tensión. El mismo autor de este TFG aportó un ejemplo y la normativa que se sigue en España para realizar estos tests. Se agradece la colaboración de la empresa \textit{Laboratorio Central Oficial de Electrotecnia,} departamento de Alta Tensión, por facilitar la información.

\subsection{Soporte técnico a usuarios} \label{sct:desarrollo:soporte_tecnico}

Otro aspecto, de no gran importancia ya que no se ha dispuesto de mucho tiempo para ello, es el soporte técnico a usuarios. Se ha respondido a preguntas en \textit{GitHub}, y en la lista de correo por \textit{Google Groups}. Implicarse en esto ha permitido conocer mejor la librería, detectar errores en el código y adelantar futuros errores con las dependencias.

Es más, respecto de las dependencias, se inicia parcialmente un trabajo en eliminar una sub-dependencia de una de las dependencias, valga la redundancia, de \textit{pvlib-python}. Se trata de \textit{solarfactors}, un clon mantenido por la comunidad de \textit{pvlib} del paquete \textit{pvfactors}, que es un software de simulación de factores de vista en sistemas fotovoltaicos bifaciales.

Sucede que esta dependencia utiliza una versión antigua e incompatible de \textit{Shapely}, que no se puede instalar en Python 3.12, así que se plantea eliminarla. Este trabajo, si bien iniciado, resulta especialmente complejo por trabajar con un código base novedoso para el alumno, por requerir una elevada inversión de tiempo y no estar ligado estrechamente a la librería objeto de este TFG.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Impacto en otros repositorios}

\subsection{En \textit{pvlib/solarfactors}}

Este repositorio se trata de un clon de \textit{pvfactors}, que se emplea para calcular factores de vista de sistemas fotovoltaicos bifaciales. Es un clon porque \textit{pvfactors} inició dentro de una empresa, que contaba con los permisos para administrar sus cambios, pero dejó de mantenerla. La comunidad de \textit{pvlib}, ya que la usaba en el repositorio \textit{pvlib-python}, decidió clonarla y mantenerla.

\begin{itemize}
    \item \issue{16}[https://github.com/pvlib/solarfactors]
\end{itemize}

Se ha informado sobre un problema de las dependencias de \textit{solarfactors} en \textit{Python 3.12}, y se ha propuesto eliminar la dependencia de \textit{Shapely} en favor de código nativo de Python. Se ha iniciado el trabajo, pero no se ha completado.

\subsection{En \textit{openpvtools/pv-foss-engagement}}

Este pequeño proyecto es un compendio de datos de contribuciones, contribuyentes y otras métricas relativas al impacto e interés que generan varias librerías de código abierto sobre la fotovoltaica.

Se puede consultar en \url{https://openpvtools.github.io/pv-foss-engagement/}.

\begin{itemize}
    \item \issue{8}[https://github.com/openpvtools/pv-foss-engagement]
    \item \pr{9}[https://github.com/openpvtools/pv-foss-engagement]
\end{itemize}

Se informa sobre la ausencia del clon citado anteriormente, \textit{pvlib/solarfactors}, en el repositorio. Se propone añadirlo, y un mantenedor añade los datos. Deja como posibilidad para el estudiante que proponga las modificaciones pertinentes para mostrarlo en la web.

Se plantean los cambios, sin haber respuesta a día de esta redacción.
